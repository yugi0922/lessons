# コルーチン入門：非同期処理の新しいアプローチ

## 導入：非同期処理の課題とコルーチンの誕生

### なぜ非同期処理は難しいのか

アプリケーションでは「同時に複数の処理を行いたい」場面がよくあります。
たとえば、

* 画面を表示しながらネットワーク通信をする
* 複数のAPIを同時に呼び出して、すべての結果をまとめる
* 大きなファイルを読み込みながら、ユーザー入力を受け付ける

このような「並行処理」を実現するために、Javaでは長い間 **Thread（スレッド）** が使われてきました。

---

### Threadによる並行処理の限界

ThreadはOSが直接管理する仕組みです。
そのため、1つ作るだけでもかなりのメモリ（数百KB〜数MB）を消費し、数千個も立ち上げるのは非現実的です。

また、スレッドを自分で管理するコードは複雑になりがちです。

```java
new Thread(() -> {
    try {
        var result = fetchData();
        System.out.println(result);
    } catch (Exception e) {
        e.printStackTrace();
    }
}).start();
```

スレッドの中で例外処理や完了後のコールバックを自分で書く必要があります。
これが増えていくと「**コールバック地獄（callback hell）**」が発生します。

---

### Javaの典型的な非同期処理の形

Javaでは以下のような方法が使われます。

* `new Thread { ... }`
  → 手動でスレッドを起動
* `ExecutorService.submit()`
  → スレッドプールを使ってタスクを実行
* `CompletableFuture`
  → 非同期処理をチェーンでつなぐ

例：`CompletableFuture`

```java
CompletableFuture.supplyAsync(() -> fetchData())
    .thenApply(data -> process(data))
    .thenAccept(result -> System.out.println(result));
```

便利になったように見えますが、

* 例外処理が複雑
* スレッドプールの設定が難しい
* ネストが増えると読みにくい
  という課題が残ります。

---

### Kotlinの哲学：「軽量な並行処理を安全に、シンプルに」

Kotlinは「並行処理をもっと直感的に、安全に書けるようにしたい」という思想で、
**コルーチン（Coroutine）** を導入しました。

コルーチンは「スレッドの上で動く軽量なタスク」です。

* Threadより軽く、数万個でも動かせる
* `suspend` 関数によって中断と再開が可能
* スコープを使ってライフサイクルを安全に管理できる

---

### コルーチンとは？

コルーチンとは？

一言で言えば、

「軽量なスレッド＋構造化された非同期タスクの仕組み」

これを料理にたとえると、次のようになります。

Thread の場合（従来のやり方）

Threadは「一人のシェフが一皿ずつ最初から最後まで担当する」ようなものです。
カレーを作っている間は、そのシェフは他の仕事ができません。
オーブンで焼いている時間も、ただ突っ立って見ているしかない。

新しい料理を同時に作りたければ、もう一人シェフを雇う必要があります。
しかし人件費（＝リソース）も場所（＝メモリ）もどんどん増えます。

Coroutine の場合（Kotlin的アプローチ）

Coroutineは「少人数のキッチンスタッフが、必要なときだけ動いて手際よく料理を進める」ような仕組みです。

たとえば：

Aさんがスープを煮込んでいるあいだ（待ち時間）、
→ Bさんがサラダを盛りつける。

スープが煮えたらAさんがまた戻って仕上げをする。

ここでのポイントは、
「待っている時間を無駄にせず、他の作業に切り替えられる」 こと。
Kotlinのコルーチンはこの「切り替え」を自動で最適にやってくれます。

構造化並行性（チームプレーのルール）

さらにコルーチンでは、全員が「チーム単位」で動きます。

親シェフ（＝スコープ）がキッチンを閉めたら、
→ その下で動いているスタッフ（＝子コルーチン）も全員作業を止めて片付ける。

Threadだと「誰かが勝手に残業している」ような状態になりがちですが、
Coroutineではチーム全体が同じルールで動くため、後片付けやエラー処理が自動的に整理されるのです。


# コルーチンの基礎

## (1) Thread vs Coroutine

### Thread の特徴

* OS が直接管理する
* 生成・切り替えコストが高い
* 同時に大量のスレッドを動かすとメモリ負荷が大きい

```java
new Thread(() -> {
    Thread.sleep(1000);
    System.out.println("完了");
}).start();
```

このようなコードは少数なら問題ありませんが、数千単位で並行実行するとシステムが重くなります。

---

### Coroutine の特徴

* Kotlin ランタイムが管理（ユーザー空間で動作）
* 非常に軽量（数万単位で動かしてもOK）
* 同じスレッド上で複数の処理を切り替えて実行

```kotlin
GlobalScope.launch {
    delay(1000)
    println("完了")
}
```

`delay` の間に他の処理が動くため、スレッドを占有しません。

---

`比喩で理解する`

Thread = 人が対応するレジ

一人のお客さんを担当したら、会計が終わるまで他のお客さんを処理できない。

レジを増やすには店員（Thread）を増やす必要があり、人件費（メモリ）も場所（CPU）もかかる。

Coroutine = セルフレジ

1台の端末（スレッド）を複数の客が順番に使う。

1人が袋詰めしている間に、次の人が支払い画面に進める。

店員（OS）はレジ全体を見守るだけで、実際の進行は軽やかに切り替わる。

---

## (2) `suspend` 関数

### 基本の考え方

`suspend` は「一時停止できる関数」という意味です。
コルーチンの中で呼び出すと、処理を中断して別の作業に切り替えることができます。

```kotlin
suspend fun fetchData(): String {
    delay(1000)
    return "OK"
}
```

`delay(1000)` は `Thread.sleep(1000)` のようにスレッドを止めるわけではなく、
「この処理は1秒後に再開するから、その間は他の処理を進めてね」とKotlinに伝えます。

---

### イメージで捉える

`Thread.sleep()` は「部屋を借りて寝る」。
→ 他の人はその部屋（スレッド）を使えない。

`delay()` は「一度部屋を出て、1秒後に戻る」。
→ 他の人がその間に同じ部屋を使える。

これが「スレッドを止めずに処理を待つ」というコルーチンの強みです。

---

## (3) CoroutineScope と CoroutineContext

### CoroutineScope（スコープ）

スコープはコルーチンの「生存範囲」を決めるものです。
スコープが終わると、その中で動いているコルーチンも自動的にキャンセルされます。
これにより、メモリリークや孤立タスクを防げます。

```kotlin
coroutineScope {
    launch { println("A") }
    launch { println("B") }
} // ここを抜けると両方完了
```

---

### CoroutineContext（コンテキスト）

コンテキストはコルーチンの実行環境をまとめたものです。
中には以下のような情報が入っています。

* **Dispatcher**：どのスレッドで動くか（例：IO, Default, Main）
* **Job**：状態（実行中・キャンセル・完了）

例：

```kotlin
GlobalScope.launch(Dispatchers.IO) {
    println("実行スレッド: ${Thread.currentThread().name}")
}
```

上記では `Dispatchers.IO` によって、I/O 処理向けのスレッドプール上で実行されます。

---

### まとめ

* **Thread** は OS が管理する重い単位
* **Coroutine** は Kotlin が管理する軽い単位
* **suspend 関数** で処理を一時停止・再開できる
* **CoroutineScope/Context** により、安全で構造化された並行処理が実現できる
